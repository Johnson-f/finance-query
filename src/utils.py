import functools
import hashlib
import json
import os
from datetime import datetime
from decimal import Decimal

import pytz
import redis
from dotenv import load_dotenv

from src.schemas import TimeSeries, HistoricalData, Quote, Stock
from src.schemas.time_series import TimePeriod, Interval

load_dotenv()

r = redis.Redis(
    host=os.getenv("REDIS_HOST"),
    port=os.getenv("REDIS_PORT"),
    db=0,
    username=os.getenv("REDIS_USERNAME"),
    password=os.getenv("REDIS_PASSWORD"),
    decode_responses=True,
)


def is_market_open() -> bool:
    now = datetime.now(pytz.timezone('US/Eastern'))
    open_time = datetime.now(pytz.timezone('US/Eastern')).replace(hour=9, minute=30, second=0)
    close_time = datetime.now(pytz.timezone('US/Eastern')).replace(hour=16, minute=0, second=0)
    # Check if current time is within market hours and it's a weekday
    return open_time <= now <= close_time and 0 <= now.weekday() < 5


class Encoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, TimeSeries):
            return {'history': obj.history}
        elif isinstance(obj, Quote) or isinstance(obj, Stock):
            return obj.dict()
        elif isinstance(obj, Decimal):
            return str(obj)
        elif isinstance(obj, TimePeriod):
            return obj.value
        elif isinstance(obj, Interval):
            return obj.value
        return super().default(obj)


def cache(expire, check_market=False):
    """
    This decorator caches the result of the function it decorates.

    The cache key is generated by hashing the function name and its arguments.
    The result is stored in a Redis cache with a specified expiration time.

    If the cache key exists in the Redis cache, the cached value is returned.
    If the cache key does not exist, the function is called and Redis stores the result.

    :param expire: The expiration time for the cache key
    :param check_market: Whether to check if the market is open before caching
    :return: The result of the function or the cached value
    """

    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            # Generate a unique key for the function and its arguments
            key = f"{func.__name__}:{hashlib.sha256(json.dumps((args, kwargs), cls=Encoder).encode()).hexdigest()}"

            # Check if the key exists in the Redis cache
            if (result := r.get(key)) is not None:
                result_dict = json.loads(result)
                if 'history' in result_dict:
                    result_dict['history'] = {
                        k: HistoricalData(
                            open=Decimal(v['open']),
                            high=Decimal(v['high']),
                            low=Decimal(v['low']),
                            adj_close=Decimal(v['adj_close']),
                            volume=int(v['volume'])
                        ) for k, v in result_dict['history'].items()
                    }
                    return TimeSeries(**result_dict)
                elif 'price' in result_dict and 'change' in result_dict:
                    return Stock(**result_dict)
                elif 'price' in result_dict and 'after_hours_price' in result_dict:
                    return Quote(**result_dict)

            # Call the function if no key exists in the Redis cache
            result = await func(*args, **kwargs)

            result_dict = result.to_dict() if isinstance(result, TimeSeries) else result

            # Cache the result in the Redis cache if the market is closed or check_market is False
            if not check_market or (check_market and not is_market_open()):
                r.set(key, json.dumps(result_dict, cls=Encoder), ex=expire)

            return result

        return wrapper

    return decorator
