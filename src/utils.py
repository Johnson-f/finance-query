import functools
import hashlib
import os
from datetime import datetime

import orjson
import pytz
import redis
from dotenv import load_dotenv

from src.schemas import TimeSeries, HistoricalData, Quote, Stock

load_dotenv()

r = redis.Redis(
    host=os.getenv("REDIS_HOST"),
    port=os.getenv("REDIS_PORT"),
    db=0,
    username=os.getenv("REDIS_USERNAME"),
    password=os.getenv("REDIS_PASSWORD"),
)


def is_market_open() -> bool:
    now = datetime.now(pytz.timezone('US/Eastern'))
    open_time = datetime.now(pytz.timezone('US/Eastern')).replace(hour=9, minute=30, second=0)
    close_time = datetime.now(pytz.timezone('US/Eastern')).replace(hour=16, minute=0, second=0)
    # Check if current time is within market hours and it's a weekday
    return open_time <= now <= close_time and 0 <= now.weekday() < 5


def cache(expire, check_market=False):
    """
        This decorator caches the result of the function it decorates.

        The cache key is generated by hashing the function name and its arguments.
        The result is stored in a Redis cache with a specified expiration time.

        If the cache key exists in the Redis cache, the cached value is returned.
        If the cache key does not exist, the function is called and Redis stores the result.

        :param expire: The expiration time for the cache key
        :param check_market: Whether to check if the market is open before caching
        :return: The result of the function or the cached value
        """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            key = f"{func.__name__}:{hashlib.sha256(orjson.dumps((args, kwargs))).hexdigest()}"

            if r.exists(key):
                if 'get_time_series' in key:
                    result = orjson.loads(r.get(key))
                else:
                    result_list = []
                    for item in r.lrange(key, 0, -1):
                        result_list.append(orjson.loads(item))
                    result = result_list
                return result

            result = await func(*args, **kwargs)

            #Cache the result if the market is closed or if the function is not checking the market
            if not check_market or (check_market and not is_market_open()):
                if isinstance(result, TimeSeries):
                    r.set(key, orjson.dumps(result.dict()), ex=expire)
                else:
                    if isinstance(result, list) and result and isinstance(result[0], (Stock, Quote)):
                        result_list = [item.dict() for item in result]
                    elif isinstance(result, (Stock, Quote)):
                        result_list = result.dict()
                    else:
                        result_list = result

                    for item in result_list:
                        r.rpush(key, orjson.dumps(item))
                    r.expire(key, expire)

            return result

        return wrapper

    return decorator
