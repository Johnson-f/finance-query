import decimal
import functools
import hashlib
import os
from datetime import datetime, date

import orjson
import pytz
import redis
from dotenv import load_dotenv
from pydantic import BaseModel

from src.schemas import TimeSeries, Quote, Stock, MarketMover, News, Index
from src.schemas.analysis import Analysis, SMAData, Indicator, EMAData, WMAData, VWMAData, RSIData, \
    SRSIData, STOCHData, CCIData, MACDData, ADXData, AROONData, BBANDSData, OBVData, SuperTrendData, IchimokuData

load_dotenv()

r = redis.Redis(
    host=os.getenv("REDIS_HOST"),
    port=os.getenv("REDIS_PORT"),
    db=0,
    username=os.getenv("REDIS_USERNAME"),
    password=os.getenv("REDIS_PASSWORD"),
)


def is_market_open() -> bool:
    now = datetime.now(pytz.timezone('US/Eastern'))
    open_time = datetime.now(pytz.timezone('US/Eastern')).replace(hour=9, minute=30, second=0)
    close_time = datetime.now(pytz.timezone('US/Eastern')).replace(hour=16, minute=0, second=0)
    # Check if current time is within market hours and it's a weekday
    return open_time <= now <= close_time and 0 <= now.weekday() < 5


def handle_data(obj):
    if isinstance(obj, decimal.Decimal):
        return float(obj)
    elif isinstance(obj, BaseModel):
        return obj.dict()
    elif hasattr(obj, 'to_dict'):
        return obj.to_dict()
    raise TypeError


indicators = {
    "SMA": SMAData,
    "EMA": EMAData,
    "WMA": WMAData,
    "VWMA": VWMAData,
    "RSI": RSIData,
    "SRSI": SRSIData,
    "STOCH": STOCHData,
    "CCI": CCIData,
    "MACD": MACDData,
    "ADX": ADXData,
    "AROON": AROONData,
    "BBANDS": BBANDSData,
    "OBV": OBVData,
    "SUPERTREND": SuperTrendData,
    "ICHIMOKU": IchimokuData
}


def cache(expire, after_market_expire=None):
    """
        This decorator caches the result of the function it decorates.

        The cache key is generated by hashing the function name and its arguments.
        The result is stored in a Redis cache with a specified expiration time.

        If the cache key exists in the Redis cache, the cached value is returned.
        If the cache key does not exist, the function is called and Redis stores the result.

        :param expire: The expiration time for the cache key
        :param after_market_expire: The expiration time for the cache key after the market closes
        :return: The result of the function or the cached value
        """

    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            key = f"{func.__name__}:{hashlib.sha256(orjson.dumps((args, kwargs))).hexdigest()}"

            if r.exists(key):
                if r.type(key) == b'string':
                    result = orjson.loads(r.get(key))
                elif r.type(key) == b'list':
                    result_list = []
                    for item in r.lrange(key, 0, -1):
                        result_list.append(orjson.loads(item))
                    result = result_list

                # Create instances of indicator classes for Technical Analysis
                if 'Technical Analysis' in result:
                    indicator_data = {}
                    indicator_name = result['type']
                    for key, value in result['Technical Analysis'].items():
                        if indicator_name in indicators:
                            indicator_value = indicators[indicator_name](**value)
                            indicator_data[date.fromisoformat(key)] = indicator_value
                    return Analysis(type=Indicator(indicator_name), indicators=indicator_data).model_dump(
                        exclude_none=True, by_alias=True,
                        serialize_as_any=True)
                return result

            result = await func(*args, **kwargs)

            # Set the expiration time based on the market hours
            if after_market_expire is not None and not is_market_open():
                expire_time = after_market_expire
            else:
                expire_time = expire

            # Cache the result in Redis
            if isinstance(result, dict):
                r.set(key, orjson.dumps(result, default=handle_data), ex=expire_time)
            elif isinstance(result, TimeSeries):
                r.set(key, result.json(), ex=expire_time)
            else:
                if (isinstance(result, list) and result
                        and isinstance(result[0], (Stock, Quote, MarketMover, Index, News))):
                    result_list = [item.dict() for item in result]
                elif isinstance(result, (Stock, Quote, Index, MarketMover)):
                    result_list = result.dict()
                else:
                    result_list = result

                for item in result_list:
                    r.rpush(key, orjson.dumps(item))
                r.expire(key, expire_time)

            return result

        return wrapper

    return decorator
