import functools
import hashlib
import os
from datetime import datetime

import orjson
import pytz
import redis
from dotenv import load_dotenv

from src.schemas import TimeSeries, Quote, Stock, MarketMover, News, Index

load_dotenv()

r = redis.Redis(
    host=os.getenv("REDIS_HOST"),
    port=os.getenv("REDIS_PORT"),
    db=0,
    username=os.getenv("REDIS_USERNAME"),
    password=os.getenv("REDIS_PASSWORD"),
)


def is_market_open() -> bool:
    now = datetime.now(pytz.timezone('US/Eastern'))
    open_time = datetime.now(pytz.timezone('US/Eastern')).replace(hour=9, minute=30, second=0)
    close_time = datetime.now(pytz.timezone('US/Eastern')).replace(hour=16, minute=0, second=0)
    # Check if current time is within market hours and it's a weekday
    return open_time <= now <= close_time and 0 <= now.weekday() < 5


def cache(expire, after_market_expire=None):
    """
        This decorator caches the result of the function it decorates.

        The cache key is generated by hashing the function name and its arguments.
        The result is stored in a Redis cache with a specified expiration time.

        If the cache key exists in the Redis cache, the cached value is returned.
        If the cache key does not exist, the function is called and Redis stores the result.

        :param expire: The expiration time for the cache key
        :param after_market_expire: The expiration time for the cache key after the market closes
        :return: The result of the function or the cached value
        """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            key = f"{func.__name__}:{hashlib.sha256(orjson.dumps((args, kwargs))).hexdigest()}"

            if r.exists(key):
                if 'get_time_series' in key:
                    result = orjson.loads(r.get(key))
                else:
                    result_list = []
                    for item in r.lrange(key, 0, -1):
                        result_list.append(orjson.loads(item))
                    result = result_list
                return result

            result = await func(*args, **kwargs)

            #Set the expiration time based on the market hours
            if after_market_expire is not None and not is_market_open():
                expire_time = after_market_expire
            else:
                expire_time = expire

            #Cache the result in Redis
            if isinstance(result, TimeSeries):
                r.set(key, orjson.dumps(result.dict()), ex=expire_time)
            else:
                if isinstance(result, list) and result and isinstance(result[0],
                                                                      (Stock, Quote, MarketMover, Index, News)):
                    result_list = [item.dict() for item in result]
                elif isinstance(result, (Stock, Quote, Index, MarketMover)):
                    result_list = result.dict()
                else:
                    result_list = result

                for item in result_list:
                    r.rpush(key, orjson.dumps(item))
                r.expire(key, expire_time)

            return result

        return wrapper

    return decorator
