import asyncio
import decimal
import functools
import gzip
import hashlib
import os
from datetime import date
from typing import Optional

import orjson
from aiohttp import ClientSession
from async_lru import alru_cache
from dotenv import load_dotenv
from pydantic import BaseModel
from redis import RedisError

from src.context import request_context
from src.market import MarketSchedule, MarketStatus
from src.schemas import TimeSeries, SimpleQuote, Quote, MarketMover, Index, News, MarketSector
from src.schemas.analysis import SMAData, EMAData, WMAData, VWMAData, RSIData, SRSIData, STOCHData, CCIData, MACDData, \
    ADXData, AROONData, BBANDSData, OBVData, SuperTrendData, IchimokuData, Analysis, Indicator
from src.schemas.sector import MarketSectorDetails

load_dotenv()

indicators = {
    "SMA": SMAData,
    "EMA": EMAData,
    "WMA": WMAData,
    "VWMA": VWMAData,
    "RSI": RSIData,
    "SRSI": SRSIData,
    "STOCH": STOCHData,
    "CCI": CCIData,
    "MACD": MACDData,
    "ADX": ADXData,
    "AROON": AROONData,
    "BBANDS": BBANDSData,
    "OBV": OBVData,
    "SUPERTREND": SuperTrendData,
    "ICHIMOKU": IchimokuData
}


def cache(
        expire: int = 0,
        market_closed_expire: Optional[int] = None,
        memcache: bool = False,
        market_schedule=MarketSchedule(),
):
    """
    This decorator caches the result of the function it decorates.

    The cache key is generated by hashing the function name and its arguments.
    The result is stored in a Redis cache with a specified expiration time.

    If the cache key exists in the Redis cache, the cached value is returned.
    If the cache key does not exist, the function is called and Redis stores the result.

    :param expire: The expiration time for the cache key
    :param market_closed_expire: The expiration time for the cache key after the market closes
    :param memcache: Flag to use in-memory caching instead of Redis
    :param market_schedule: DI for MarketSchedule class to check if market is open/closed

    :return: The result of the function or the cached value
    """
    use_redis = os.getenv('USE_REDIS', 'False').lower() == 'true' and not memcache

    def cache_in_redis(key, result, expire_time):
        """
        Caches the result in Redis based on the result type.
        :param key: the cache key (function name and hashed arguments)
        :param result: the response of the endpoint to cache
        :param expire_time: the expiration time for the cache key
        """

        def handle_data(obj):
            if isinstance(obj, decimal.Decimal):
                return float(obj)
            elif isinstance(obj, BaseModel):
                return obj.model_dump()
            elif hasattr(obj, 'to_dict'):
                return obj.to_dict()
            raise TypeError(f"Object of type {type(obj)} is not JSON serializable")

        try:
            request = request_context.get()
            pipe = request.app.state.redis.pipeline()
            if isinstance(result, dict):
                data = gzip.compress(orjson.dumps(result, default=handle_data))
                pipe.set(key, data)
                pipe.expire(key, expire_time)
            elif isinstance(result, (
            SimpleQuote, Quote, MarketMover, Index, News, MarketSector, MarketSectorDetails, TimeSeries)):
                data = gzip.compress(result.model_dump_json(by_alias=True, exclude_none=True).encode())
                pipe.set(key, data)
                pipe.expire(key, expire_time)
            else:
                result_list = result
                if isinstance(result, list) and result and isinstance(result[0], (
                SimpleQuote, Quote, MarketMover, Index, News, MarketSector)):
                    result_list = [item.dict() for item in result]
                pipe.delete(key)
                for item in result_list:
                    pipe.rpush(key, gzip.compress(orjson.dumps(item)))
                pipe.expire(key, expire_time)
            pipe.execute()
        except RedisError as e:
            print(f"Redis caching error: {str(e)}")
            return None

    def decorator(func):
        if not use_redis:
            is_closed = market_schedule.get_market_status()[0] != MarketStatus.OPEN
            expire_time = market_closed_expire if (market_closed_expire and is_closed) else expire
            return alru_cache(maxsize=512, ttl=expire_time)(func)

        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            lock = asyncio.Lock()
            async with (lock):
                filtered_args = [arg for arg in args if not isinstance(arg, ClientSession)]
                filtered_kwargs = {k: v for k, v in kwargs.items() if not isinstance(v, ClientSession)}
                key = f"{func.__name__}:{hashlib.sha256(orjson.dumps((filtered_args, filtered_kwargs))).hexdigest()}"
                is_closed = market_schedule.get_market_status()[0] != MarketStatus.OPEN
                expire_time = market_closed_expire if (market_closed_expire and is_closed) else expire
                try:
                    # We need to access the request object to get the Redis client from app state
                    request = request_context.get()

                    if request.app.state.redis.exists(key):
                        key_type = request.app.state.redis.type(key)
                        if key_type == b'string':
                            data = gzip.decompress(request.app.state.redis.get(key))
                            result = orjson.loads(data)
                        elif key_type == b'list':
                            result_list = []
                            items = request.app.state.redis.lrange(key, 0, -1)
                            if not items:
                                raise KeyError("Cache key exists but no items found")
                            for item in items:
                                data = gzip.decompress(item)
                                result_list.append(orjson.loads(data))
                            result = result_list
                        else:
                            raise ValueError(f"Unexpected Redis key type: {key_type}")

                        if isinstance(result, dict) and 'Technical Analysis' in result:
                            indicator_data = {}
                            indicator_name = result['type']
                            for key, value in result['Technical Analysis'].items():
                                if indicator_name in indicators:
                                    indicator_value = indicators[indicator_name](**value)
                                    indicator_data[date.fromisoformat(key)] = indicator_value
                            return Analysis(
                                type=Indicator(indicator_name),
                                indicators=indicator_data
                            ).model_dump(exclude_none=True, by_alias=True, serialize_as_any=True)

                        return result

                except orjson.JSONDecodeError as e:
                    request.app.state.redis.delete(key)
                    print(f"Cache corruption detected: {str(e)}")

                result = await func(*args, **kwargs)
                if result is None:
                    return None

                cache_in_redis(key, result, expire_time)
                return result

        return wrapper

    return decorator
